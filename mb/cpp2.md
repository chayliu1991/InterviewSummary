# 拷贝构造函数、赋值运算符

拷贝构造函数必须以引用的方式传递参数。这是因为，在值传递的方式传递给一个函数的时候，会调用拷贝构造函数生成函数的实参。如果拷贝构造函数的参数仍然是以值的方式，就会无限循环的调用下去，直到函数的栈溢出。

拷贝构造函数和赋值运算符的行为比较相似，都是将一个对象的值复制给另一个对象；但是其结果却有些不同，调用的是拷贝构造函数还是赋值运算符，主要是看是否有新的对象实例产生。如果产生了新的对象实例，那调用的就是拷贝构造函数；如果没有，那就是对已有的对象赋值，调用的是赋值运算符：

- 拷贝构造函数使用传入对象的值生成一个新的对象的实例

- 而赋值运算符是将对象的值复制给一个已经存在的实例

调用拷贝构造函数主要有以下场景：

- 对象作为函数的参数，以值传递的方式传给函数
- 对象作为函数的返回值，以值的方式从函数返回
- 使用一个对象给另一个对象初始化


# const 和 #define区别

- 编译器处理方式不同
   - define宏是在预处理阶段展开
  - const常量是编译运行阶段使用
- 类型和安全检查不同
- - define宏没有类型，不做任何类型检查，仅仅是展开
  - const常量有具体的类型，在编译阶段会执行类型检查
- 可调式
  -  const常量可以进行调试的
  -  define是不能进行调试的，因为在预编译阶段就已经替换掉
- 存储方式
  - define只是进行展开，有多少地方使用，就替换多少次，它定义的宏常量在内存中有若干个备份，占用代码段空间
  - const定义的只读变量在程序运行过程中只有一份备份，占用数据段空间
- 特殊功能：
  - define可以用来防止头文件重复引用，而const不能
  - const 修饰类成员函数，define 不可以
- 重定义
  - define可以通过undef取消某个符号的定义，再重新定义
  - const不能重定义

# strcpy和memcpy的区别

```
char* strcpy(char* dest,char* src)
{
    if(src == NULL || dest == NULL)
        return NULL;
        char* res = dest;

    while((*dest++ = *src++) != '\0')
        ;

    return res;
}

void* memcpy(void* dest,void* src,size_t size)
{
    if(dest == NULL || src  == NULL)
        return NULL;

    char* pd = (char*)dest;
    char* ps = (char*)src;

    while(size --)
        *pd++ = *ps++;

    return dest;
}
```

- 复制的内容不同:
  - strcpy只能复制字符串
  - 而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等
- 复制的方法不同:
  - strcpy不需要指定长度，它遇到被复制字符的串结束符"\0"才结束，所以容易溢出
  - memcpy则是根据其第3个参数决定复制的长度。
- 用途不同:
  - 通常在复制字符串时用strcpy
  - 而需要复制其他类型数据时则一般用memcpy

# 野指针和空悬指针、

## 空悬指针

dangling pointer，指向已经销毁的对象或已经回收的地址。以下情况可能出现空悬指针：

```
//@ 情况一
{
   char *dp = NULL;

   {
       char c;
       dp = &c;
   }
  //变量c释放，dp变成空悬指针
}

//@ 情况二
void func()
{
    char *dp = (char *)malloc(A_CONST);
    free(dp);         //dp变成一个空悬指针
    dp = NULL;        //dp不再是空悬指针
    /* ... */
}

//@ 情况三
int * func ( void )
{
    int num = 1234;
    /* ... */
    return &num;
}
```

## 野指针

指针变量未初始化：任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存

# extern和static使用

当定义一个变量的时候，就包含了对该变量声明的过程，同时在内存张申请了一块内存空间。如果在多个文件中使用相同的变量，为了避免重复定义，就必须将声明和定义分离开来。定义是创建与名字关联的实体。声明是让名字为程序所知，当一个文件想要使用其他文件定义的某个变量，则必须包含对那个文件的声明：

- 函数和变量的声明不会分配内存, 但是定义会分配相应的内存空间
- 函数和变量的声明可以有很多次, 但是定义最多只能有一次
- 函数的声明和定义方式默认都是 extern 的, 即函数默认是全局的
- 变量的声明和定义方式默认都是局部的, 在当前编译单元或者文件内可用

# STL
## 六大组件
- 容器：各种数据结构的实现，类模板
- 算法：各种常用算法的实现，函数模板
- 迭代器：容器和算法之间的桥梁，泛型指针，所有容器都有属于自己类型的迭代器，迭代器分为五种类型：
  - 输入迭代器
  - 输出迭代器
  - 正向迭代器：forward_list，unordered_set/unordered_multiset,unordered_map/unordered_multimap
  - 双向迭代器：list，set/multiset,map/multimap
  - 随机访问迭代器：vector,deque,array
- 仿函数，重载了 operator() 的类或者模板类
- 适配器：
  - 容器适配器：以某种容器作为底层数据结构，例如 stack，queue,priority_queue
  - 迭代器适配器：reverse_iterator,back_inserter,front_inserter,back_inserter
  - 算法适配器:bind1st,bind2nd
- 分配器：负责空间配置和管理

## 容器适配器的底层数据结构
- stack 和 queue 的底层默认容器都是 deque。pirority_queue 底层默认容器是 vector  
- 容器适配器没有迭代器

在stack中元素增长时，deque比vector的效率高；queue中的元素增长时，deque不仅效率高，而且内存使用率高。vector 当容量不够时，会开更大的空间，拷数据然后释放原来的空间，操作复杂。而deque会找另一块内存继续存放数据，效率高。
相比较list，deque的插入操作会更加的高效，而且内存的使用率高，list会导致更多的内存碎片。


# 互斥量与信号量的区别
- 互斥量用于线程的互斥，信号量用于线程的同步
  - 互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的
  - 同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源
- 互斥量值只能为0/1，信号量值可以为非负整数
  - 也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问
- 互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到


# 不能声明为虚函数的几种情况
- 普通函数（非成员函数）：定义虚函数的主要目的是为了重写达到多态，所以普通函数声明为虚函数没有意义，因此编译器在编译时就绑定了它
- 静态成员函数：静态成员函数对于每个类都只有一份代码，所有对象都可以共享这份代码，他不归某一个对象所有，所以它也没有动态绑定的必要
- 内联成员函数：内联函数本就是为了减少函数调用的代价，所以在代码中直接展开。但虚函数一定要创建虚函数表，这两者不可能统一。另外，内联函数在编译时被展开，而虚函数在运行时才动态绑定
- 构造函数：因为构造函数本来是为了初始化对象成员才产生的，然而虚函数的目的是为了在完全不了解细节的情况下也能正确处理对象，两者根本不能“ 好好相处 ”。因为虚函数要对不同类型的对象产生不同的动作，如果将构造函数定义成虚函数，那么对象都没有产生，怎么完成想要的动作
- 友元函数：当我们把一个函数声明为一个类的友元函数时，它只是一个可以访问类内成员的普通函数，并不是这个类的成员函数，自然也不能在自己的类内将它声明为虚函数


# C++中指针和引用的区别
- 指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已
- 引用不可以为空，当被创建的时候，必须初始化，而指针可以是空值，可以在任何时候被初始化
- 以有const指针，但是没有const引用
- 指针可以有多级，但是引用只能是一级（int **p;合法 而 int &&a是不合法的）
- 指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了
- "sizeof引用"得到的是所指向的变量(对象)的大小，而"sizeof指针"得到的是指针本身的大小
- 指针和引用的自增(++)运算意义不一样
