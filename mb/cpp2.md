# 拷贝构造函数、赋值运算符

拷贝构造函数必须以引用的方式传递参数。这是因为，在值传递的方式传递给一个函数的时候，会调用拷贝构造函数生成函数的实参。如果拷贝构造函数的参数仍然是以值的方式，就会无限循环的调用下去，直到函数的栈溢出。

拷贝构造函数和赋值运算符的行为比较相似，都是将一个对象的值复制给另一个对象；但是其结果却有些不同，调用的是拷贝构造函数还是赋值运算符，主要是看是否有新的对象实例产生。如果产生了新的对象实例，那调用的就是拷贝构造函数；如果没有，那就是对已有的对象赋值，调用的是赋值运算符：

- 拷贝构造函数使用传入对象的值生成一个新的对象的实例

- 而赋值运算符是将对象的值复制给一个已经存在的实例

调用拷贝构造函数主要有以下场景：

- 对象作为函数的参数，以值传递的方式传给函数
- 对象作为函数的返回值，以值的方式从函数返回
- 使用一个对象给另一个对象初始化


# const 和 #define区别

- 编译器处理方式不同
   - define宏是在预处理阶段展开
  - const常量是编译运行阶段使用
- 类型和安全检查不同
- - define宏没有类型，不做任何类型检查，仅仅是展开
  - const常量有具体的类型，在编译阶段会执行类型检查
- 可调式
  -  const常量可以进行调试的
  -  define是不能进行调试的，因为在预编译阶段就已经替换掉
- 存储方式
  - define只是进行展开，有多少地方使用，就替换多少次，它定义的宏常量在内存中有若干个备份，占用代码段空间
  - const定义的只读变量在程序运行过程中只有一份备份，占用数据段空间
- 特殊功能：
  - define可以用来防止头文件重复引用，而const不能
  - const 修饰类成员函数，define 不可以
- 重定义
  - define可以通过undef取消某个符号的定义，再重新定义
  - const不能重定义

# strcpy和memcpy的区别

```
char* strcpy(char* dest,char* src)
{
    if(src == NULL || dest == NULL)
        return NULL;
        char* res = dest;

    while((*dest++ = *src++) != '\0')
        ;
    
    return res;
}

void* memcpy(void* dest,void* src,size_t size)
{
    if(dest == NULL || src  == NULL)
        return NULL;
    
    char* pd = (char*)dest;
    char* ps = (char*)src;

    while(size --)
        *pd++ = *ps++;
    
    return dest;
}
```

- 复制的内容不同:
  - strcpy只能复制字符串
  - 而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等
- 复制的方法不同:
  - strcpy不需要指定长度，它遇到被复制字符的串结束符"\0"才结束，所以容易溢出
  - memcpy则是根据其第3个参数决定复制的长度。
- 用途不同:
  - 通常在复制字符串时用strcpy
  - 而需要复制其他类型数据时则一般用memcpy

# 野指针和空悬指针、

## 空悬指针

dangling pointer，指向已经销毁的对象或已经回收的地址。以下情况可能出现空悬指针：

```
//@ 情况一
{
   char *dp = NULL;

   {
       char c;
       dp = &c;
   } 
  //变量c释放，dp变成空悬指针
}

//@ 情况二
void func()
{
    char *dp = (char *)malloc(A_CONST);
    free(dp);         //dp变成一个空悬指针
    dp = NULL;        //dp不再是空悬指针
    /* ... */
}

//@ 情况三
int * func ( void )
{
    int num = 1234;
    /* ... */
    return &num;
}
```

## 野指针

指针变量未初始化：任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存

# extern和static使用

当定义一个变量的时候，就包含了对该变量声明的过程，同时在内存张申请了一块内存空间。如果在多个文件中使用相同的变量，为了避免重复定义，就必须将声明和定义分离开来。定义是创建与名字关联的实体。声明是让名字为程序所知，当一个文件想要使用其他文件定义的某个变量，则必须包含对那个文件的声明：

- 函数和变量的声明不会分配内存, 但是定义会分配相应的内存空间
- 函数和变量的声明可以有很多次, 但是定义最多只能有一次
- 函数的声明和定义方式默认都是 extern 的, 即函数默认是全局的
- 变量的声明和定义方式默认都是局部的, 在当前编译单元或者文件内可用

https://www.cnblogs.com/helloworldcode/p/11191231.html



