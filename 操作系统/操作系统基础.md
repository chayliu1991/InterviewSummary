# 用户态内核态

为了限制不同程序的访问能力，划分了用户态和内核态两个权限等级。

- 用户态只能访问受限的资源，如果需要特殊权限，可以通过系统调用获取相应的资源
- 内核态可以访问所有的 CPU 指令和所有的内存空间、I/O 空间和硬件设备

所有用户程序都运行在用户态，一些内核态的操作需要进行系统调用，CPU切换到内核态，执行相应的服务，再切换为用户态并返回系统调用的结果。

为什么要有内核态和用户态：

- 安全性：防止用户程序恶意或者不小心破坏系统/内存/硬件资源
- 封装性：用户程序不需要实现更加底层的代码
- 利于调度：便于操作系统统一调度

用户态切换到内核态的 3 种方式：

- 系统调用：通过系统调用申请使用内核态服务程序完成工作，比如 fork()，本质通过中断来实现
- 异常：用户态下的程序，发生了某些不可知的异常，会切换到处理此异常的内核程序，也就转到了内核态，比如缺页异常
- 外围设备的中断：当外围设备完成用户请求的操作后，会发出相应的中断信号，程序转而去执行中断处理程序

为什么用户态切换到内核态代价大？

当发生用户态到内核态的切换时，会发生如下过程（本质上是从“用户程序”切换到“内核程序”）

- 设置处理器至内核态
- 保存当前寄存器（栈指针、程序计数器、通用寄存器）
- 将栈指针设置指向内核栈地址
- 将程序计数器设置为一个事先约定的地址上，该地址上存放的是系统调用处理程序的起始地址

而之后从内核态返回用户态时，又会进行类似的工作。

## 内核空间和用户空间

内核空间总是驻留在内存中，它是为操作系统的内核保留的。按访问权限可以分为：

- 进程私有：每个进程都有单独的内核栈、页表、task 结构以及 mem_map 结构等
- 进程共享：包括物理存储器、内核数据和内核代码区域。

用户进程都有一个单独的用户空间，处于用户态的进程不能访问内核空间中的数据，需要通过系统调用，切换到内核态。用户空间包括：

- 运行时栈：由编译器自动释放，存放函数的参数值，局部变量和方法返回值等。每当一个函数被调用时，该函数的返回类型和一些调用的信息被存储到栈顶，调用结束后调用信息会被弹出弹出并释放掉内存。栈区是从高地址位向低地址位增长的
- 运行时堆：用于存放进程运行中被动态分配的内存段。由开发人员申请分配和释放。堆是从低地址位向高地址位增长，采用链式存储结构
- 代码段：存放 CPU 可以执行的机器指令。通常代码区是共享的，即其它执行程序可调用它
- 未初始化的数据段：存放未初始化的全局变量
- 已初始化的数据段：存放已初始化的全局变量，包括静态全局变量、静态局部变量以及常量。
- 内存映射区域：例如将动态库，共享内存等虚拟空间的内存映射到物理空间的内存

