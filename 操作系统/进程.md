# 

进程是程序在某个数据集合上的一次运行活动，也是操作系统进行资源分配和保护的基本单位。

进程就是程序的一次执行过程，程序是静态的，它作为系统中的一种资源是永远存在的。而进程是动态的，它是动态的产生，变化和消亡的，拥有其自己的生命周期。

# 进程的组成

进程主要由三个部分组成：

- 进程控制块 PCB。每个进程有且仅有一个进程控制块（Process Control Block，PCB），或称进程描述符，它是进程存在的唯一标识，是操作系统用来记录和刻画进程状态及环境信息的数据结构，也是操作系统掌握进程的唯一资料结构和管理进程的主要依据。所以说 PCB 是提供给操作系统使用的。包含如下几个部分：
  - 进程描述信息：当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的 “身份证号”— PID（ProcessID，进程 ID）
  - 进程控制和管理信息：记录进程的运行情况。比如 CPU 的使用时间、磁盘使用情况、网络流量使用情况等
  - 资源分配清单：记录给进程分配了哪些资源。比如分配了多少内存、正在使用哪些 I/O 设备、正在使用哪些文件等
  - CPU 相关信息：进程在让出 CPU 时，必须保存该进程在 CPU 中的各种信息，比如各种寄存器的值。用于实现进程切换，确保这个进程再次运行的时候恢复 CPU 现场，从断点处继续执行。这就是所谓的保存现场信息

- 数据段。即进程运行过程中各种数据（比如程序中定义的变量）
- 程序段。就是程序的代码（指令序列）

# 进程的状态

三态模型：

- 运行态（running）：进程占有 CPU 正在运行
- 就绪态（ready）：进程具备运行条件，等待系统分配 CPU 以便运行
- 阻塞态 / 等待态（wait）：进程不具备运行条件，正在等待某个事件的完成

![](E:\share\InterviewSummary\操作系统\img\process_three_status.png)



五态模型：

- 新建态（new）：进程正在被创建时的状态
- 终止态（exit）：进程正在从系统中消失时的状态

![](E:\share\InterviewSummary\操作系统\img\process_five_status.png)



需要注意的是：

- 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度
- 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态

## 进程控制

所谓进程控制就是对系统中的所有进程实施有效的管理，实现进程状态转换功能。包括创建进程、阻塞进程、唤醒进程、终止进程等。这些功能均由原语来实现。原语是一种特殊的程序，它的执行具有原子性。 也就是说，这段程序的运行必须一气呵成，不可中断。原语是操作系统内核里的一段程序：

![](E:\share\InterviewSummary\操作系统\img\primitive.png)

### 进程的创建

操作系统初始启动时会创建承担系统资源分配和控制管理的一些系统进程，同时还会创建一个所有用户进程的祖先，其他用户进程是在应用程序运行时创建的。

操作系统允许一个进程创建另一个进程，而且允许子进程继承父进程所拥有的资源，当子进程被终止时，其在父进程处继承的资源应当还给父进程。同时，终止父进程时同时也会终止其所有的子进程。

创建进程的过程，也就是创建原语包含的内容如下：

- 在进程列表中增加一项，从 PCB 池中申请一个空闲的 PCB（PCB 是有限的，若申请失败则创建失败），为新进程分配一个唯一的进程标识符
- 为新进程分配地址空间，由进程管理程序确定加载至进程地址空间中的程序
- 为新进程分配各种资源
- 初始化 PCB，如进程标识符、CPU 初始状态等
- 把新进程的状态设置为就绪态，并将其移入就绪队列，等待被调度运行

### 进程的终止

进程的终止也称为撤销，进程完成特定工作或出现严重错误后必须被终止。引起进程终止的事件有三种：

- 正常结束：进程自己请求终止（exit 系统调用）
- 异常结束：比如整数除 0，非法使用特权指令，然后被操作系统强行终止
- 外界干预：用户手动杀死进程

终止（撤销）进程的过程，也就是撤销原语包含的内容如下：

- 从 PCB 集合中找到终止进程的 PCB
- 若进程处于运行态，则立即剥夺其 CPU，终止该进程的执行，然后将 CPU 资源分配给其他进程；
- 如果其还有子进程，则应将其所有子进程终止
- 将该进程所拥有的全部资源都归还给父进程或操作系统
- 回收 PCB 并将其归还至 PCB 池

### 进程的阻塞和唤醒

进程阻塞是指进程让出 CPU 资源转而等待一个事件，如等待资源、等待 I/O 操作完成等。进程通常使用阻塞原语来阻塞自己，所以阻塞是进程的自主行为，是一个同步事件。当等待事件完成时会产生一个中断，激活操作系统，在系统的控制下将被阻塞的进程唤醒，也就是唤醒原语。进程的阻塞和唤醒显然是由进程切换来完成的。

进程的阻塞步骤，也就是阻塞原语的内容为：

- 找到将要被阻塞的进程对应的 PCB
- 保护进程运行现场，将 PCB 状态信息设置为阻塞态，暂时停止进程运行
- 将该 PCB 插入相应事件的阻塞队列（等待队列）

进程的唤醒步骤，也就是唤醒原语的内容为：

- 在该事件的阻塞队列中找到相应进程的 PCB
- 将该 PCB 从阻塞队列中移出，并将进程的状态设置为就绪态
- 把该 PCB 插入到就绪队列中，等待被调度程序调度

阻塞原语和唤醒原语的作用正好相反，阻塞原语使得进程从运行态转为阻塞态，而唤醒原语使得进程从阻塞态转为就绪态。如果某个进程使用阻塞原语来阻塞自己，那么他就必须使用唤醒原语来唤醒自己，因何事阻塞，就由何事唤醒，否则被阻塞的进程将永远处于阻塞态。因此，阻塞原语和唤醒原语是成对出现的。

## 进程上下文切换

所谓进程的上下文切换，就是说各个进程之间是共享 CPU 资源的，不可能一个进程永远占用着 CPU 资源，不同的时候进程之间需要切换，使得不同的进程被分配 CPU 资源，这个过程就是进程的上下文切换，一个进程切换到另一个进程运行。

因为进程是由内核进行管理和调度的，所以进程的上下文切换一定发生在内核态。

进程上下文的切换也是一个原语操作，称为切换原语，其内容如下：

- 首先，将进程 A 的运行环境信息存入 PCB，这个运行环境信息就是进程的上下文（Context）

- 然后，将 PCB 移入相应的进程队列

- 选择另一个进程 B 进行执行，并更新其 PCB 中的状态为运行态

- 当进程 A 被恢复运行的时候，根据它的 PCB 恢复进程 A 所需的运行环境

引起进程上下文切换的事件，也就是某个占用 CPU 资源运行的当前进程被赶出 CPU 的原因有如下：

- 当前进程的时间片到
- 有更高优先级的进程到达
- 当前进程主动阻塞
- 当前进程终止

## 进程调度算法

### 批处理系统

批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。

- 先来先服务 first-come first-serverd（FCFS）
  - 非抢占式的调度算法，按照请求的顺序进行调度
  - 有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长

- 短作业优先 shortest job first（SJF）
  - 非抢占式的调度算法，按估计运行时间最短的顺序进行调度
  - 长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度

- 最短剩余时间优先 shortest remaining time next（SRTN）
  - 最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待

###  交互式系统

交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。

- 时间片轮转
  - 将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程
  - 时间片轮转算法的效率和时间片的大小有很大关系：
    - 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间
    - 而如果时间片过长，那么实时性就不能得到保证
- 优先级调度
  - 为每个进程分配一个优先级，按优先级进行调度
  - 为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级
- 多级反馈队列
  - 一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合

![](E:\share\InterviewSummary\操作系统\img\multi_feedback.png)

### 实时系统

实时系统要求一个请求在一个确定时间内得到响应。

分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。

## 进程同步

###  临界区

对临界资源进行访问的那段代码称为临界区。为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。

```
// entry section
// critical section;
// exit section
```

### 同步与互斥

同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。

互斥：多个进程在同一时刻只有一个进程能进入临界区。

### 信号量

信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。

- down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；
- up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。

down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。

如果信号量的取值只能为 0 或者 1，那么就成为了 互斥量（Mutex） ，0 表示临界区已经加锁，1 表示临界区解锁。

### 管程

使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。

管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。

管程引入了 条件变量 以及相关的操作：wait() 和 signal() 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。

# 进程通信

进程通信（InterProcess Communication，IPC）就是指进程之间的信息交换。

为了保证安全，每个进程的用户地址空间都是独立的，一般而言一个进程不能直接访问另一个进程的地址空间，不过内核空间是每个进程都共享的，所以进程之间想要进行信息交换就必须通过内核。

![](E:\share\InterviewSummary\操作系统\img\ipc.png)

 Linux 内核提供的常见的进程通信机制：

- 管道（也称作共享文件）
- 消息队列（也称作消息传递）
- 共享内存（也称作共享存储）
- 信号量和 PV 操作
- 信号
- 套接字（Socket）

## 管道

### 匿名管道

- 管道的数据是单向流动的
- 匿名管道只能用于父子进程之间的通信

通过 `pipe` 函数来创建匿名管道：

```
int pipe (int fd[2]);  //@ 若创建成功则返回 0，创建失败就返回 -1
```

pipe 返回了两个文件描述符， 这表示管道的两端， 一个是管道的读取端描述符 fd[0]， 另一个是管道的写入端描述符 fd[1]。

匿名管道实现进程间通信的步骤：

- 父进程创建两个匿名管道，管道 1（fd1[0]和 fd1[1]）和管道 2（fd2[0] 和 fd2[1]）；因为管道的数据是单向流动的，所以要想实现数据双向通信，就需要两个管道，每个方向一个
- 父进程 fork 出子进程，于是对于这两个匿名管道，子进程也分别有两个文件描述符指向匿名管道的读写两端
- 父进程关闭管道 1 的读端 fd1[0] 和 管道 2 的写端 fd2[1]，子进程关闭管道 1 的写端 fd1[1] 和 管道 2 的读端 fd2[0]，这样，管道 1 只能用于父进程写、子进程读；管道 2 只能用于父进程读、子进程写。管道是用环形队列实现的，数据从写端流入从读端流出，这就实现了父子进程之间的双向通信

![](E:\share\InterviewSummary\操作系统\img\anonymous_pipe.png)

管道的本质就是内核在内存中开辟了一个缓冲区，这个缓冲区与管道文件相关联，对管道文件的操作，被内核转换成对这块缓冲区的操作。

### 有名管道

匿名管道由于没有名字，只能用于父子进程间的通信。为了克服这个缺点，提出了有名管道，也称做 FIFO，因为数据是先进先出的传输方式。所谓有名管道也就是提供一个路径名与之关联，这样，即使与创建有名管道的进程不存在亲缘关系的进程，只要可以访问该路径，就能够通过这个有名管道进行相互通信。

![](E:\share\InterviewSummary\操作系统\img\fifo.png)

````
#include <sys/stat.h>
int mkfifo(const char *path, mode_t mode);
int mkfifoat(int fd, const char *path, mode_t mode);
````

## 消息队列

管道这种进程通信方式虽然使用简单，但是效率比较低，不适合进程间频繁地交换数据，并且管道只能传输无格式的字节流。为此，消息传递机制（Linux 中称消息队列）应用而生。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程在需要的时候自行去消息队列中读取数据就可以了。同样的，B 进程要给 A 进程发送消息也是如此。

![](E:\share\InterviewSummary\操作系统\img\msg_queue.png)

消息队列的本质就是存放在内存中的消息的链表，而消息本质上是用户自定义的数据结构。如果进程从消息队列中读取了某个消息，这个消息就会被从消息队列中删除。对比一下管道机制：

- 消息队列允许一个或多个进程向它写入或读取消息
- 消息队列可以实现消息的随机查询，不一定非要以先进先出的次序读取消息，也可以按消息的类型读取。比有名管道的先进先出原则更有优势
- 对于消息队列来说，在某个进程往一个队列写入消息之前，并不需要另一个进程在该消息队列上等待消息的到达。而对于管道来说，除非读进程已存在，否则先有写进程进行写入操作是没有意义的
- 消息队列的生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列就会一直存在。而匿名管道随进程的创建而建立，随进程的结束而销毁

```
key_t ftok(const char *pathname, int proj_id); //@ 生成消息队列的唯一标识
int msgget(key_t key, int msgflg); //@ 创建/获取一个消息队列
int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg); //@ 发送消息
ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,int msgflg);  //@ 获取消息
```



需要注意的是，消息队列对于交换较少数量的数据很有用，因为无需避免冲突。但是，由于用户进程写入数据到内存中的消息队列时，会发生从用户态拷贝数据到内核态的过程；同样的，另一个用户进程读取内存中的消息数据时，会发生从内核态拷贝数据到用户态的过程。因此，如果数据量较大，使用消息队列就会造成频繁的系统调用，也就是需要消耗更多的时间以便内核介入。

## 共享内存

为了避免像消息队列那样频繁的拷贝消息、进行系统调用，共享内存机制出现了。共享内存就是允许不相干的进程将同一段物理内存连接到它们各自的地址空间中，使得这些进程可以访问同一个物理内存，这个物理内存就称为共享内存。如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。

每个进程都有属于自己的进程控制块（PCB）和逻辑地址空间（Addr Space），并且都有一个与之对应的页表，负责将进程的逻辑地址（虚拟地址）与物理地址进行映射，通过内存管理单元（MMU）进行管理。两个不同进程的逻辑地址通过页表映射到物理空间的同一区域，它们所共同指向的这块区域就是共享内存。

![](E:\share\InterviewSummary\操作系统\img\shm.png)

不同于消息队列频繁的系统调用，对于共享内存机制来说，仅在建立共享内存区域时需要系统调用，一旦建立共享内存，所有的访问都可作为常规内存访问，无需借助内核。这样，数据就不需要在进程之间来回拷贝，所以这是最快的一种进程通信方式。

![](E:\share\InterviewSummary\操作系统\img\shm2.png)

```
int shmget(key_t key, size_t size, int flag); //@ 创建共享内存
int shmctl(int shm_id, int cmd, struct shmid_ds *buf); //@ 操作共享内存
int shmdt(void *addr);  //@ 共享内存解除绑定
```

## 信号量和 PV 操作

实际上，对具有多 CPU 系统的最新研究表明，在这类系统上，消息传递的性能其实是要优于共享内存的，因为消息队列无需避免冲突，而共享内存机制可能会发生冲突。也就是说如果多个进程同时修改同一个共享内存，先来的那个进程写的内容就会被后来的覆盖。

进程的同步与互斥其实是一种对进程通信的保护机制，并不是用来传输进程之间真正通信的内容的，但是由于它们会传输信号量，所以也被纳入进程通信的范畴，称为低级通信。

信号量其实就是一个变量 ，我们可以用一个信号量来表示系统中某种资源的数量，用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现进程互斥或同步。这一对原语就是 PV 操作：

- P 操作：将信号量值减 1，表示申请占用一个资源。如果结果小于 0，表示已经没有可用资源，则执行 P 操作的进程被阻塞。如果结果大于等于 0，表示现有的资源足够你使用，则执行 P 操作的进程继续执行
- V 操作：将信号量值加 1，表示释放一个资源，即使用完资源后归还资源。若加完后信号量的值小于等于 0，表示有某些进程正在等待该资源，由于我们已经释放出一个资源了，因此需要唤醒一个等待使用该资源（就绪态）的进程，使之运行下去

P 操作和 V 操作必须成对出现。缺少 P 操作就不能保证对共享内存的互斥访问，缺少 V 操作就会导致共享内存永远得不到释放、处于等待态的进程永远得不到唤醒。

```
int semget(key_t key, int num_sems, int sem_flags);  //@ 创建或打开信号量集
int semctl(int semid, int semnum, int cmd, union semun args); //@ 得到一个信号量集标识符或创建一个信号量集对象
int semop(int semid, struct sembuf semoparray[], size_t numops); //@ pv 操作
```



互斥访问共享内存：

![](E:\share\InterviewSummary\操作系统\img\pv_shm.png)

实现进程同步：

![](E:\share\InterviewSummary\操作系统\img\pv_process_sync.png)

## 信号

信号和信号量是完全不同的两个概念！

信号是进程通信机制中唯一的异步通信机制，它可以在任何时候发送信号给某个进程。通过发送指定信号来通知进程某个异步事件的发送，以迫使进程执行信号处理程序。信号处理完毕后，被中断进程将恢复执行。用户、内核和进程都能生成和发送信号。

信号事件的来源主要有硬件来源和软件来源。所谓硬件来源就是说我们可以通过键盘输入某些组合键给进程发送信号，比如常见的组合键 Ctrl+C 产生 SIGINT 信号，表示终止该进程；而软件来源就是通过 kill 系列的命令给进程发送信号，比如 kill -9 1111 ，表示给 PID 为 1111 的进程发送 SIGKILL 信号，让其立即结束。我们来查看一下 Linux 中有哪些信号：

![](E:\share\InterviewSummary\操作系统\img\signals.png)

## Socket

上面介绍的 5 种方法都是用于同一台主机上的进程之间进行通信的，如果想要跨网络与不同主机上的进程进行通信，这就是 Socket 通信做的事情了。

## 工具

System V IPC体系有一个统一的命令行工具： ipcmk， ipcs和ipcrm用于创建、 查看和删除 IPC 对象  











