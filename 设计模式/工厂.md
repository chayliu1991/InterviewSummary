```

#include <memory>
#include <string>
#include <iostream>

namespace SimpleFactory
{
	enum class CarType
	{
		Benz,
		BMW,
	};

	class Car
	{
	public:
		virtual std::string name() = 0;
		virtual ~Car() = default;
	};

	class BenzCar : public Car
	{
		public:
		virtual std::string name() override
		{
			return "BenzCar";
		}
	};

	class BMWCar : public Car
	{
	public:
		virtual std::string name() override
		{
			return "BMWCar";
		}
	};


	static std::shared_ptr<Car> create_car(CarType type)
	{
		std::shared_ptr<Car> p_car;
		if (type == CarType::Benz)
		{
			p_car.reset(new BenzCar);
		}
		else if (type == CarType::BMW)
		{
			p_car.reset(new BMWCar);
		}
		return p_car;
	}

	void client()
	{
		auto car = create_car(CarType::BMW);
		std::cout << car->name() << std::endl;
	}
}


namespace FactoryMethod
{
	class Car
	{
	public:
		virtual std::string name() = 0;
	};

	class BenzCar : public Car
	{
	public:
		virtual std::string name() override
		{
			return "BenzCar";
		}
	};

	class BMWCar : public Car
	{
	public:
		virtual std::string name() override
		{
			return "BMWCar";
		}
	};

	class CarFactory
	{
	public :
		virtual std::shared_ptr<Car> create() = 0;
	};

	class BenzFactory : public CarFactory
	{
	public:
		virtual std::shared_ptr<Car> create()
		{
			return std::make_shared<BenzCar>();
		}
	};

	class BMWFactory : public CarFactory
	{
	public:
		virtual std::shared_ptr<Car> create()
		{
			return std::make_shared<BMWCar>();
		}
	};

	void client()
	{
		BenzFactory benz_factory;
		auto benz_car = benz_factory.create();
		std::cout << benz_car->name() << std::endl;

		BMWFactory bmw_factory;
		auto bmw_car = bmw_factory.create();
		std::cout << bmw_car->name() << std::endl;
	}
}


namespace AbstractFactory
{
	class Car
	{
	public:
		virtual std::string name() = 0;
		virtual ~Car() = default;
	};

	class Bike
	{
	public:
		virtual std::string name() = 0;
		virtual ~Bike() = default;
	};

	class BenzCar : public Car
	{
	public:
		virtual std::string name() override
		{
			return "Benz Car";
		}
	};

	class BenzBike : public Bike
	{
	public:
		virtual std::string name() override
		{
			return "Benz Bike";
		}
	};

	class BmwCar : public Car
	{
	public:
		virtual std::string name() override
		{
			return "Bmw Car";
		}
	};

	class BmwBike : public Bike
	{
	public:
		virtual std::string name() override
		{
			return "Bmw Bike";
		}
	};
	
	enum class FactoryType
	{
		Benz_Factory,
		BMW_Factory
	};

	class AFactory
	{
	public:

		virtual std::unique_ptr<Car>  create_car() = 0;
		virtual std::unique_ptr<Bike> create_bike() = 0;
		static std::unique_ptr<AFactory> create_factory(FactoryType type);
	};

	class BenzFactory : public AFactory
	{
	public:
		virtual std::unique_ptr<Car>  create_car() override
		{
			return std::make_unique<BenzCar>();
		}

		virtual std::unique_ptr<Bike> create_bike() override
		{
			return std::make_unique<BenzBike>();
		}
	};

	class BmwFactory : public AFactory
	{
	public:
		virtual std::unique_ptr<Car>  create_car() override
		{
			return std::make_unique<BmwCar>();
		}
		virtual std::unique_ptr<Bike> create_bike() override
		{
			return std::make_unique<BmwBike>();
		}
	};

	std::unique_ptr<AFactory> AFactory::create_factory(FactoryType type)
	{
		std::unique_ptr<AFactory> p_factory{ nullptr };
		if (type == FactoryType::Benz_Factory)
		{
			p_factory.reset(new BenzFactory());
		}
		else if (type == FactoryType::BMW_Factory)
		{
			p_factory.reset(new BmwFactory());
		}
		return p_factory;
	}

	void client()
	{
		auto factory = AFactory::create_factory(FactoryType::Benz_Factory);
		auto car = factory->create_car();
		auto bike = factory->create_bike();

		std::cout << car->name() << std::endl;
		std::cout << bike->name() << std::endl;
	}
}



int main()
{
	SimpleFactory::client();
	FactoryMethod::client();
	AbstractFactory::client();

    return 0;
}


```

